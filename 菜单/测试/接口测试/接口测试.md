### 接口测试



![](https://i.loli.net/2020/11/16/nOmp5vR7I8kicfh.png)



![](https://i.loli.net/2020/11/17/i8spkjIbWgdnKOQ.png)

**1、什么是接口测试？**



​       接口测试是测试系统组件间接口的一种测试。接口测试主要用于检测外部系统与系统之间以及内部各个子系统之间的交互点。测试的重点是要检查数据的交换，传递和控制管理过程，以及系统间的相互逻辑依赖关系等



**2、为什么要做接口测试**

​        a)**互联网**的快速发展，公司内部系统或与外部系统的关联越来越多，一个业务流程关联多个后端系统，它们的关联都是基于接口来实现，接口测试可以将复杂的系统关联进行简化，只要做好每个接口的测试就能够较好的保证系统质量。
​       b)单个系统的变更，是否会影响到关联业务系统，比较难用常规的测试方面来覆盖相关的应用系统（例如使用此接口的外部 系统有N个，不可能每个做功能兼容性测试），但可以通过对接口功能的覆盖来验证是否影响它人对接口的调用。
​      c)接口功能比较单一，能够比较好的进行测试覆盖，也相对容易实现自动化持续集成，，可以减少人工回归成本与时间，缩短测试周期。
​      d)接口相对于界面功能，会更底层一些，测试覆盖会更容易（如业务在调用接口时做了判断，当不满足条件时链接就不显示，此时从界面无法测试相关功能是否做好判断，通过接口就比较容易）

![img](https://i.loli.net/2020/11/17/8uVRNzl64hZHyGw.jpg)

##### 3、接口都有哪些类型？

​         接口一般分为两种：1.程序内部的接口 2.系统对外的接口

　　系统对外的接口：比如你要从别的网站或服务器上获取资源或信息，别人肯定不会把 数据库共享给你，他只能给你提供一个他们写好的方法来获取数据，你引用他提供的接口就能使用他写好的方法，从而达到数据共享的目的。

　　程序内部的接口：方法与方法之间，模块与模块之间的交互，程序内部抛出的接口，比如bbs系统，有登录模块、发帖模块等等，那你要发帖就必须先登录，那么这两个模块就得有交互，它就会抛出一个接口，供内部系统进行调用。

　　接口的分类：

​                              1.webservice接口 

​                              2.http api接口

　　webService接口是走soap协议通过http传输，请求报文和返回报文都是xml格式的，我们在测试的时候都用通过工具才能进行调用，测试。

　　http api接口是走http协议，通过路径来区分调用的方法，请求报文都是key-value形式的，返回报文一般都是json串，有get和post等方法，这也是最常用的两种请求方式。

　　json是一种通用的数据类型，所有的语言都认识它。（json的本质是字符串，他与其他语言无关，只是可以经过稍稍加工可以转换成其他语言的数据类型，比如可以转换成 Python中的字典，key-value的形式，可以转换成JavaScript中的原生对象，可以转换成 java中的类对象等。）



##### 4、怎么做接口测试

​      -由于我们项目前后端调用主要是基于http协议的接口，所以测试接口时主要是通过工具或代码模拟http请求的发送与接收。工具有很多如：postman、 jmeter、soupUI、java+httpclient、robotframework+httplibrary等。



##### 5、接口测试要点是什么



​        目的：测试接口的正确性和稳定性；

　　原理：模拟客户端向服务器发送请求报文，服务器接收请求报文后对相应的报文做处理并向客户端返回应答，客户端接收应答的过程；

　　重点：检查数据的交换，传递和控制管理过程，还包括处理的次数；

　　核心：持续集成是接口测试的核心；

　　优点：为高复杂性的平台带来高效的缺陷监测和质量监督能力，平台越复杂，系统越庞大，接口测试的效果越明显（提高测试效率，提升用户体验，降低研发成本）；

　　 用例设计重点：通常情况下主要测试最外层的两类接口:数据进入系统接口（调用外部系统的参数为本系统使用）和数据流出系统接口（验证系统处理后的数据是否正常）；



**6、接口测试范围**

a)业务功能（包括正常、异常场景是否实现）
b)业务规则（覆盖度是否全面）
c)参数验证（边界、业务规则是否达到要求）
d)异常场景（重复提交、并发提交、事务中断、多机环境、大数据量测试）
e)性能测试（响应时间、吞吐量、并发数、资源要求）
f)安全测试（权限验证、SQL注入等）



##### 7、接口用例设计方法

   接口测试用例设计的重点，在于功能性的业务逻辑检查和参数检查。

1、功能：

检查接口基础功能，是否完成了业务逻辑要求。此处的用例设计方法，和普通的测试用例设计方法一样。可以把接口当作一个待测模块，分析接口功能需求，利用常规用例方法设计测试用例。可供参考的用例设计方法如下：



```
1、等价类划分法

2、边界值分析法

3、错误推断法

4、因果图法

5、判定表驱动法

6、正交试验法

7、功能图法

8、场景图法
```

 

2、数据：分析接口的输入参数，覆盖各种可能的场景。

（1）检查接口的输入，数据格式、数据类型、数据范围等

（2）检查接口的参数边界（传递的参数足够大或者为负、空值时）

（3）检查接口的参数的组合，可选、必选等

（4）检查接口的约束条件，不符合约束条件的，不需要设计用例



##### 8、接口测试质量评估



接口测试用例在执行了一段时间后，需要对用例进行质量评估，即是对用例进行维护和优化。评估的内容可以参考如下几条：

(1)业务功能需求覆盖率

(2)异常场景覆盖是否完整

(3)代码覆盖率

(4)用例的有效性，检查出Bug的概率

(5)用例的错误率，bug误报指数

(6)测试数据维护成本，mock数据的准确性



#### 做好接口测试的前提



**1、系统化的接口文档**

传统的接口文档，一般采用word或wiki等系统来**记录**，从单次使用上似乎比较简单，因为大家会更习惯这样的操作，但这种形式存在比较大的问题：

a、接口文档非标准化，无法直接与接口测试工具接口使用
b、接口维护困难，接口有变化时比较难标识清楚，沟通成本很高
系统化接口文档，例如rap（淘宝分源的一个系统），具备接口维护标准化、版本化管理、MOCK测试等功能；对标准化的接口内容做二次开发，可以直接导出Soapui等工具使用的格式，直接导入工具中使用，有以下好处：
A、接口测试时不再需要手工输入相关字段，节省时间成本
B、版本化管理，能够清晰的知道哪些接口有变化
Rap参考 http://rapapi.org/org/index.do



**2、标准化的接口规范**



​       接口管理是做好接口测试很重要的前提，如果一个系统有哪些接口都不太清楚，测试就很难覆盖到，接口管理建议采用以下方式：
A、按接口提供方为单位进行首次划分，按接口使用方进行二次划分，再按业务模块进行细分，分类原则根据内容多少进行优化，不需要固定，如本身接口较少就没有必要分得过细，较多时就需要多划分模块



如：系统A，提供有 1、2、3、4、5、6、7、8、9 这9个接口，接口分别给B系统、C系统使用，其中1、2为公用接口，3、4、5为B专用，6、7、8、9为C系统专用，划分如下：

B、按接口链接URL做为唯一，不同的接口参数做为接口变量，接口有参数变更时在原来接口上进行维护，而不是新增加接口
C、为接口增加版本号，方便清楚哪些接口本次有变更，易于维护用例

 



##### 3、接口测试都要掌握哪些知识



​        ①了解系统及内部各个组件之间的业务逻辑交互；

　　②了解接口的I/O（input/output：输入输出）；

　　③了解协议的基本内容，包括：通信原理、三次握手、常用的协议类型、报文构成、数据传输方式、常见的状态码、URL构成等；

　　④常用的接口测试工具，比如：jmeter、loadrunner、postman、soapUI等；

　　⑤数据库基础操作命令（检查数据入库、提取测试数据等）；

　　⑥常见的字符类型，比如：char、varchar、text、int、float、datatime、string等；　



#### 



下面以一个web接口作为案例，接口说明文档如下：



```c
接口名称：获取用户名单
请求URL：{$url}/getUserOrder
请求方式：POST
返回举例：
略
```



请求参数 ：



| 名称     | 必选 | 类型   | 说明     |
| -------- | ---- | ------ | -------- |
| uid      | Y    | String | 用户id   |
| orderNum | N    | Int    | 订单数量 |

根据业务流程、输入参数、输出返回、性能、安全5块内容对接口进行用例设计。参考如下：

| 业务流程用例     |                           |
| ---------------- | ------------------------- |
|                  | 获取用户订单成功          |
|                  | 用户订单不存在            |
|                  | 用户不存在                |
|                  | 获取用户订单异常          |
| **输入参数用例** |                           |
|                  | uid不为空，orderNum不为空 |
|                  | uid为空，orderNum为空     |
|                  | uid为空，orderNum不为空   |
|                  | uid不为空，orderNum为空   |
|                  | uid正确，orderNum不为空   |
|                  | uid正确，orderNum为空     |
|                  | uid错误，orderNum不为空   |
|                  | uid错误，orderNum为空     |
|                  | orderNum=-1               |
|                  | orderNum=0                |
|                  | orderNum=1                |
|                  | orderNum=5                |
|                  | orderNum=100000           |
|                  | orderNum                  |
|                  | uid数据格式错误           |
|                  | orderNum数据格式错误      |
| **输出结果用例** |                           |
|                  | 返回空值                  |
|                  | 返回有效订单              |
|                  | 返回错误信息              |
|                  | 返回超市信息              |
| **性能用例**     | ......                    |
| **安全用例**     | ......                    |
|                  |                           |



用例筛选：

​         此接口，接近30个用例，已经比较全面了，但实际上有点冗余。比如，如果调用接口的界面是个用户选择界面，那么参数上，会受到约束，uid/orderNum都从前端传入，是一些固定的值，那么就不会产生一些特殊情况。类似以下情况，就不会在实际中遇到，因此这些用例的价值趋于0，完全可以在用例文档中去除。



| uid为空，orderNum为空   |
| ----------------------- |
| uid为空，orderNum为空   |
| orderNum=-1             |
| orderNum=0              |
| orderNum=100000         |
| orderNum数据格式错误    |
| uid数据格式错误         |
| uid错误，orderNum不为空 |
| uid错误，orderNum为空   |

​     设计的用例在考虑全面之后，需要再做一次减法，保证用例的实效性。对无法出现的场景设计出来的用例，毫无价值，只会增加我们的工作量，对产品质量提升没有帮助。因此，测试用例并不是越多越好，在于该用例是否能真正预防bug。





